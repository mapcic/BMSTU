\section{Метод конечных разностей для самосогласованного решение системы Шредингера--Пуассона}
Для решения системы Шредингера-Пуассона (\ref{eq:P-S}) применяют метод Гумеля. Метод Гумеля заключается в учете характера зависимости концентрации электронов от самосогласованного потенциала ($V_{S}$):
\begin{gather}
	n(z) = \frac{2^{1/2}m^{3/2}k_{B}T}{(2\pi)^{2}\hbar^{3}} \exp \frac{E_{F} - E_{c} +eV_{s}(z)}{k_{B}T} = n_{0}\exp\frac{V_{S}(z)}{V_{ref}};\\
	n_{0} = \frac{2^{1/2}m^{3/2}k_{B}T}{(2\pi)^{2}\hbar^{3}} \exp \frac{E_{F} - E_{c} }{k_{B}T};\\
	V_{ref} = \frac{k_{B}T}{e},
\end{gather}
\begin{conditions}
	$V_{s}$ & самосогласованный потенциал;\\
	$V_{ref}$ & опорный потенциал;\\
	$m$ & эффективная масса электрона.
\end{conditions}
Тогда связь <<старого>> и <<нового>> потенциала:
\begin{gather}
	\begin{cases}
		n_{old} = n_{0}\exp\frac{V_{old}}{V_{ref}};\\
		n_{new} = n_{0}\exp\frac{V_{new}}{V_{ref}};
	\end{cases}\\
	\label{eq:nNewOld}
	n_{new} = n_{old}\exp\frac{V_{new} - V_{old}}{V_{ref}};
\end{gather}

Подставляя (\ref{eq:nNewOld}) в (\ref{eq:P-S}):
\begin{equation}
 	\frac{d}{dz}\varepsilon(z)\frac{d}{z}V_{new} = \frac{e}{\varepsilon_{0}}\bigg[n_{old}\exp\bigg( \frac{V_{new} - V_{old}}{V_{ref}} \bigg) - N_{D}(z)\bigg];
\end{equation}

Так как $\frac{V_{new} - V_{old}}{V_{ref}}$ мало, используя разложение в ряд Маклорена $\exp(x) \approx 1 + x$, получим:
\begin{equation}
	\frac{d}{dz}\varepsilon(z)\frac{d}{z}V_{new} - n_{old}\frac{eV_{new}}{\varepsilon_{0}V_{ref}} = \frac{e}{\varepsilon_{0}}\bigg[n_{old}\bigg( 1 - \frac{V_{old}}{V_{ref}} \bigg) - N_{D}(z)\bigg];
\end{equation}

Применяя метод конечных разностей, получим:
\begin{equation}
	\begin{cases}
		a^{i}V_{new}^{i-1} + b^{i}V_{new}^{i} + c^{i}V^{i+1}_{new} = \frac{e\Delta^{2}}{\varepsilon_{0}\varepsilon^{i}}\bigg( n_{old}^{i}\bigg( 1 - \frac{V_{old}^{i}}{V_{ref}} \bigg) - N_{D}^{i} \bigg);\\
		a^{i} = 1;\\
		b^{i} = -1 - \frac{\varepsilon^{i+1}}{\varepsilon^{i}} -\frac{e\Delta^{2}n_{old}^{i}}{\varepsilon_{0} V_{ref}\varepsilon_{i}};\\
		c^{i} = \frac{\varepsilon^{i+1}}{\varepsilon^{i}};
	\end{cases}
\end{equation}
Граничные условия:
\begin{equation}
	V^{1}_{new} = 0;
	V^{N}_{new} = V;
\end{equation}

И продолжаем рассчитывать эту систему до достижения максимальной погрешности $\epsilon_{V}$, если выполняется условие:
\begin{equation}
 	\max(|V_{new}^{i} - V_{old}^{i}|) < \epsilon_{V},
\end{equation} 
процесс итерации останавливается.

\begin{lstlisting}[style=realcode,language=Matlab,caption={Алгоритм оценки дипломных работ}]
function J = getJ(dx, meff, Ec, dU, EFermi, r, a, b, c)
	e = 1.6e-19; eVtoJ = e; JtoEv = e^(-1); 
	hbar = 1.054*1e-34; k_B = 1.38e-23;
	T = 300;
	kT = T*k_B;

	k = ((2*meff(1)*e*kT)/(4*pi^2*hbar^3));
	J = k*ones(1, length(dU));

	ni = 1e12;
	Nd = 1e24;

	Ni = [Nd*ones(1, r), ni*ones(size(Ec)), Nd*ones(1, r)];

	eps = 13.18 - 3.12*[zeros(1, r), zeros(1, a), ones(1, b), zeros(1, c), ones(1, b), zeros(1, a), zeros(1, r)];

	for j = 1:length(dU)
		[V, n] = getConcentrationElectrons(0.001,...
			[Ec(1)*ones(1, r), Ec, Ec(end)*ones(1, r)],...
			[meff(1)*ones(1, r), meff, meff(end)*ones(1, r)],...
			Ni,...
			eps,...
			dx,...
			dU(j),...
			r + 1,...
			r + length(Ec)...
		);
		Uj = Ec - V(r+1:length(Ec)+r)*eVtoJ;
		dTDEz = @(Ez) TDEz(dx, meff, Uj, Ez, EFermi);
		J(j) = J(j)*integral(dTDEz, 0, max(Uj), 'AbsTol', 1e-200);
	end
end
\end{lstlisting}

\begin{lstlisting}[style=realcode,language=Matlab,caption={Алгоритм оценки дипломных работ}]
function [Vnew,nold] = getConcentrationElectrons(accur, Ec, meff, Ni, eps, dx, dV, boundL, boundR)
	e = 1.6e-19; eVtoJ = e; JtoEv = e^(-1); 	

	lenEc = length(Ec);
	
	Vnew = [zeros(1, boundL-1), linspace(0, dV*JtoEv, boundR - boundL + 1), dV*JtoEv*ones(1, lenEc - boundR)];
	Vold = Vnew + 10;
	
	while ( max(abs(Vnew - Vold)) > accur )
		Vold = Vnew;
		Ui = Ec - Vold*eVtoJ;

		nold = getNz(Ui, meff, dx, boundL, boundR);
        
        Vnew = solvePoisonEq(dV, Vold, nold, eps, Ni, dx);
	end
	Ui = Ec - Vnew*eVtoJ;
	nold = getNz(Ui, meff, dx, boundL, boundR);
end
\end{lstlisting}

\begin{lstlisting}[style=realcode,language=Matlab,caption={Алгоритм оценки дипломных работ}]
function nz = getNz(Ui, meff, dx, boundL, boundR)
	e = 1.6e-19; eVtoJ = e; JtoEv = e^(-1); 
	hbar = 1.0551*1e-34; k_B = 1.38e-23;
	T=300;

	EFermi=1.51e-20;

	Nc3D = 4*pi*(2*meff(1)/(2*pi*hbar)^2)^(3/2);
	Nc3DActive = sqrt(2)*meff(end)^(3/2)*k_B*T/((2*pi)^2*hbar^3);
	
	function res = NEz(Ui, meff, dx, Ez, U1, Un)
		[waveL, waveR] = getWaveFunction(dx, meff, Ui, Ez);

		waveL = abs(waveL).^2;
		waveR = abs(waveR).^2;
		
		Ez = repmat(Ez', 1, length(Ui));
		
		waveL = Nc3DActive*(waveL)./sqrt(Ez - Ui(1)).*log(1 + exp((EFermi + U1 - Ez)/(k_B*T)));
		waveL( Ez <= Ui(1) ) = 0;
		
		waveR = Nc3DActive*waveR./sqrt(Ez - Ui(end)).*log(1 + exp((EFermi + Un - Ez)/(k_B*T)));
		waveR( Ez <= Ui(end) ) = 0;
		
		res = waveL + waveR;
	end

	foo = @(Ez) NEz( Ui(boundL: boundR), meff(boundL: boundR), dx, Ez, Ui(1), Ui(end) );
	nzA = integral(foo, Ui(end), 2*e, 'AbsTol', 1E-100, 'ArrayValued', true);

	U1 = Ui(1: boundL-1);
	U2 = Ui(boundR + 1: end);

	nzL = zeros(1, length(U1));
	nzR = zeros(1, length(U2));

	for j = 1 : length(U1)
		foo = @(Ez) sqrt(Ez - U1(j))./(1 + exp((Ez - (EFermi + Ui(1)))/(k_B*T)));
		nzL(j) = Nc3D*integral(foo, U1(j), 2*e, 'AbsTol', 1e-100);
	end

	for j = 1 : length(U2)
		foo = @(Ez) sqrt(Ez - U2(j))./(1 + exp((Ez - (EFermi + Ui(end)))/(k_B*T)));
		nzR(j) = Nc3D*integral(foo, U2(j), 2*e, 'AbsTol', 1e-100);
	end

	nz = [nzL, nzA, nzR];
end

\end{lstlisting}
\begin{lstlisting}[style=realcode,language=Matlab,caption={Алгоритм оценки дипломных работ}]
function Vnew = solvePoisonEq(dU, Vold, nold, eps, Ni, dx)
	e = 1.6e-19; eVtoJ = e; JtoEv = e^(-1); 	
	k_B = 1.38e-23; eps0 = 8.85e-12;

	T = 300;
	Vref = k_B*T*JtoEv;

	lenV = length(Vold);
	
	d1 = [ones(1, lenV-2), 0];
	
	d2 = ...
		-1 ...
		-(eps(1:end-2)./eps(3:end))...
		-e*dx^2/(eps0*Vref)./eps(3:end).*nold(2:end-1);
	d2 = [1, d2, 1];

	d3 = eps(1:end-2)./eps(3:end);
	d3 = [0, d3];
	
	dfree = ...
		e/eps0*dx^2 ...
		./eps(1:end-2)...
		.*(nold(2:end-1).*(1-Vold(2:end-1)/Vref)-Ni(2:end-1));
	dfree = [0, dfree, dU*JtoEv]';
	
	Matrix = diag(d1, -1) + diag(d2) + diag(d3, 1);
	Vnew = (Matrix\dfree)';
end
\end{lstlisting}
